import { createAsyncThunk, createSlice } from '@reduxjs/toolkit';

import type { RootState } from '.';
import type {
  FetchStatus,
  ResponseData,
  SimpleGithubOrgData,
} from '../../types';
import { GITHUB_API_ENDPOINT } from '../util/constants';
import errorMap from '../util/maps/errorMap';

export interface SimpleOrgState {
  dataByName: Record<string, SimpleGithubOrgData>;
  list: {
    status: FetchStatus;
    error: string;
    meta: { totalCount: number; page: number };
    nameList: string[];
  };
  recommend: {
    status: FetchStatus;
    error: string;
    nameList: string[];
  };
}

const initialState: SimpleOrgState = {
  dataByName: {},
  list: {
    status: 'idle',
    error: '',
    meta: {
      totalCount: 0,
      page: 0,
    },
    nameList: [],
  },
  recommend: {
    status: 'idle',
    error: '',
    nameList: ['vercel', 'figma', 'mswjs', 'facebook', 'Dcard', 'strapi'],
  },
};

export const fetchSimpleOrgsByQuery = createAsyncThunk<
  {
    meta: SimpleOrgState['list']['meta'];
    nameList: SimpleOrgState['list']['nameList'];
    dataByName: SimpleOrgState['dataByName'];
  },
  {
    query: string;
    page?: number;
    per_page?: number;
  },
  {
    rejectValue: { message: string };
  }
>(
  'simpleOrg/fetchSimpleOrgsByQuery',
  async (
    {
      query,
      page = 1,
      per_page = 15, // Default = 30
    },
    { rejectWithValue }
  ) => {
    try {
      const { status, message, ...data } = (await fetch(
        `${GITHUB_API_ENDPOINT}/search/users?q=type:org+in:login+in:name+${encodeURIComponent(
          query
        )}&page=${page}&per_page=${per_page}`
      ).then((r) =>
        r.json().then((d) => ({ status: r.status, ...d }))
      )) as ResponseData<{ total_count: number; items: SimpleGithubOrgData[] }>;

      if (status !== 200) {
        throw new Error(message);
      }

      const normalizedData = data.items.reduce(
        (preVal, curVal) => ({
          names: [...preVal.names, curVal.login],
          byNames: {
            ...preVal.byNames,
            [curVal.login]: curVal,
          },
        }),
        {
          names: [],
          byNames: {},
        } as {
          names: SimpleOrgState['list']['nameList'];
          byNames: SimpleOrgState['dataByName'];
        }
      );

      return {
        meta: { totalCount: data.total_count, page },
        nameList: normalizedData.names,
        dataByName: normalizedData.byNames,
      };
    } catch (err) {
      let errMessage = errorMap.COMMON;

      if (err instanceof Error && err.message) {
        errMessage = err.message;
      }

      if (errMessage.includes('API rate limit')) {
        errMessage = errorMap.API_RATE_LIMIT;
      }

      return rejectWithValue({ message: errMessage });
    }
  }
);

export const fetchSimpleRecommendOrgs = createAsyncThunk<
  {
    dataByName: SimpleOrgState['dataByName'];
  },
  undefined,
  {
    state: RootState;
    rejectValue: { message: string };
  }
>(
  'simpleOrg/fetchSimpleRecommendOrgs',
  async (_, { rejectWithValue, getState }) => {
    const {
      simpleOrg: {
        recommend: { nameList },
      },
    } = getState();
    try {
      const { status, message, ...data } = (await fetch(
        `${GITHUB_API_ENDPOINT}/search/users?q=type:org+in:login+in:name+${encodeURIComponent(
          nameList.join(' OR ')
        )}&per_page=${nameList.length}`
      ).then((r) =>
        r.json().then((d) => ({ status: r.status, ...d }))
      )) as ResponseData<{ total_count: number; items: SimpleGithubOrgData[] }>;

      if (status !== 200) {
        throw new Error(message);
      }

      const normalizedData = data.items.reduce(
        (preVal, curVal) => ({
          byNames: {
            ...preVal.byNames,
            [curVal.login]: curVal,
          },
        }),
        {
          byNames: {},
        } as {
          byNames: SimpleOrgState['dataByName'];
        }
      );

      return {
        dataByName: normalizedData.byNames,
      };
    } catch (err) {
      let errMessage = errorMap.COMMON;

      if (err instanceof Error && err.message) {
        errMessage = err.message;
      }

      if (errMessage.includes('API rate limit')) {
        errMessage = errorMap.API_RATE_LIMIT;
      }

      return rejectWithValue({ message: errMessage });
    }
  }
);

export const simpleOrgSlice = createSlice({
  name: 'simpleOrg',
  initialState,
  reducers: {
    resetsimpleOrgList: (state) => {
      state.list = initialState.list;
    },
  },
  // The `extraReducers` field lets the slice handle actions defined elsewhere,
  // including actions generated by createAsyncThunk or in other slices.
  extraReducers: (builder) => {
    builder
      .addCase(fetchSimpleOrgsByQuery.pending, (state) => {
        state.list.status = 'loading';
        state.list.error = '';
      })
      .addCase(fetchSimpleOrgsByQuery.fulfilled, (state, action) => {
        state.list.status = 'success';
        state.list.meta = action.payload.meta;
        state.list.nameList =
          action.payload.meta.page === 1
            ? action.payload.nameList
            : [...state.list.nameList, ...action.payload.nameList];
        state.dataByName = {
          ...state.dataByName,
          ...action.payload.dataByName,
        };
      })
      .addCase(fetchSimpleOrgsByQuery.rejected, (state, action) => {
        state.list.status = 'failed';
        state.list.error = action.payload?.message || '';
      })
      .addCase(fetchSimpleRecommendOrgs.pending, (state) => {
        state.recommend.status = 'loading';
        state.list.error = '';
      })
      .addCase(fetchSimpleRecommendOrgs.fulfilled, (state, action) => {
        state.recommend.status = 'success';
        state.dataByName = {
          ...state.dataByName,
          ...action.payload.dataByName,
        };
      })
      .addCase(fetchSimpleRecommendOrgs.rejected, (state, action) => {
        state.recommend.status = 'failed';
        state.recommend.error = action.payload?.message || '';
      });
  },
});

export default simpleOrgSlice.reducer;

export const { resetsimpleOrgList } = simpleOrgSlice.actions;
export const selectSimpleOrg = (state: RootState) => state.simpleOrg;
