import { createAsyncThunk, createSlice } from '@reduxjs/toolkit';

import type { RootState } from '.';
import type { FetchStatus, ResponseData, GithubOrgData } from '../../types';
import { GITHUB_API_ENDPOINT } from '../util/constants';
import errorMap from '../util/maps/errorMap';

export interface OrganizationState {
  dataByLoginName: Record<string, GithubOrgData>;
  singleData: {
    status: FetchStatus;
    error: string;
  };
}

const initialState: OrganizationState = {
  dataByLoginName: {},
  singleData: {
    status: 'idle',
    error: '',
  },
};

export const fetchOrgnizationByLoginName = createAsyncThunk<
  {
    loginName: string;
    data: GithubOrgData;
  },
  {
    loginName: string;
  },
  {
    rejectValue: { message: string };
  }
>(
  'organization/fetchOrgnizationByLoginName',
  async ({ loginName }, { rejectWithValue }) => {
    try {
      const { status, message, ...data } = (await fetch(
        `${GITHUB_API_ENDPOINT}/orgs/${encodeURIComponent(loginName)}`
      ).then((r) =>
        r.json().then((d) => ({ status: r.status, ...d }))
      )) as ResponseData<GithubOrgData>;

      if (status !== 200) {
        throw new Error(message);
      }

      return {
        loginName,
        data,
      };
    } catch (err) {
      let errMessage = errorMap.COMMON;

      if (err instanceof Error && err.message) {
        errMessage = err.message;
      }

      if (errMessage.includes('API rate limit')) {
        errMessage = errorMap.API_RATE_LIMIT;
      }

      return rejectWithValue({ message: errMessage });
    }
  }
);

export const organizationSlice = createSlice({
  name: 'organization',
  initialState,
  reducers: {},
  // The `extraReducers` field lets the slice handle actions defined elsewhere,
  // including actions generated by createAsyncThunk or in other slices.
  extraReducers: (builder) => {
    builder
      .addCase(fetchOrgnizationByLoginName.pending, (state) => {
        state.singleData.status = 'loading';
        state.singleData.error = '';
      })
      .addCase(fetchOrgnizationByLoginName.fulfilled, (state, action) => {
        state.singleData.status = 'success';
        state.dataByLoginName = {
          ...state.dataByLoginName,
          [action.payload.loginName]: action.payload.data,
        };
      })
      .addCase(fetchOrgnizationByLoginName.rejected, (state, action) => {
        state.singleData.status = 'failed';
        state.singleData.error = action.payload?.message || '';
      });
  },
});

export default organizationSlice.reducer;

export const selectOrganization = (state: RootState) => state.organization;
